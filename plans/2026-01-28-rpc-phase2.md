# RPC Phase 2: Server-Side Implementation

## Overview

Implement server-side RPC by adding `Weaver.fromSurface(Surface)` to look up or construct Weavers at runtime. This composes existing weavers - no new weaver classes needed.

## Key Insight

Following airframe-codec's `ObjectCodec` pattern:
- Surface provides: param names, param surfaces, objectFactory
- Weavers provide: how to encode/decode each type
- Combine them at runtime without complex code generation

For RPC, we don't construct objects from requests - we just decode parameters to `Seq[Any]` and pass to `method.call(instance, args*)`.

## Wire Protocol

### Request

```
POST /{package.path.ClassName}/{methodName}
Content-Type: application/json

{
  "request": {
    "param1": value1,
    "param2": value2
  }
}
```

Parameter names use canonical matching (CName) - `userId`, `user_id`, `user-id` all match.

### Response

```
HTTP/1.1 200 OK
Content-Type: application/json
X-RPC-Status: 0

{...result...}
```

## Implementation

### 1. Weaver.fromSurface - Compose Existing Weavers

**File**: `uni/src/main/scala/wvlet/uni/weaver/Weaver.scala`

```scala
object Weaver:
  // ... existing code ...

  private val surfaceWeaverCache = ConcurrentHashMap[String, Weaver[?]]().asScala

  /**
   * Get or create a Weaver from Surface at runtime.
   * Composes existing weavers - no new weaver classes.
   */
  def fromSurface(surface: Surface): Weaver[?] =
    surfaceWeaverCache.getOrElseUpdate(surface.fullName, buildWeaver(surface))

  private def buildWeaver(surface: Surface): Weaver[?] =
    import PrimitiveWeaver.given
    surface match
      // Primitives - return existing givens
      case s if s.rawType == classOf[Int]        => intWeaver
      case s if s.rawType == classOf[Long]       => longWeaver
      case s if s.rawType == classOf[String]     => stringWeaver
      case s if s.rawType == classOf[Boolean]    => booleanWeaver
      case s if s.rawType == classOf[Double]     => doubleWeaver
      case s if s.rawType == classOf[Float]      => floatWeaver
      case s if s.rawType == classOf[Byte]       => byteWeaver
      case s if s.rawType == classOf[Short]      => shortWeaver
      case s if s.rawType == classOf[Char]       => charWeaver
      case s if s.rawType == classOf[BigInt]     => bigIntWeaver
      case s if s.rawType == classOf[BigDecimal] => bigDecimalWeaver
      case s if s.rawType == classOf[UUID]       => uuidWeaver
      case s if s.rawType == classOf[Instant]    => instantWeaver

      // Option[A] - construct with inner weaver
      case s: OptionSurface =>
        OptionWeaver(fromSurface(s.elementSurface))

      // Seq/List - construct with element weaver
      case s if s.isSeq =>
        SeqWeaver(fromSurface(s.typeArgs.head), s.rawType)

      // Map - construct with key/value weavers
      case s if s.isMap =>
        MapWeaver(fromSurface(s.typeArgs(0)), fromSurface(s.typeArgs(1)))

      // Enum
      case s: EnumSurface =>
        EnumWeaver(s)

      // Case class - use existing CaseClassWeaver
      case s if s.objectFactory.isDefined =>
        val fieldWeavers = s.params.map(p => fromSurface(p.surface)).toIndexedSeq
        CaseClassWeaver(s, fieldWeavers)

      case s =>
        throw IllegalArgumentException(s"Cannot create Weaver for: ${s.fullName}")
```

### 2. Refactor Collection Weavers to Named Classes

Extract existing `given` logic into reusable classes:

**File**: `uni/src/main/scala/wvlet/uni/weaver/codec/PrimitiveWeaver.scala` (modify)

```scala
// Extract from existing givens - same logic, just named classes

class OptionWeaver(inner: Weaver[?]) extends Weaver[Option[?]]:
  override def pack(p: Packer, v: Option[?], config: WeaverConfig): Unit =
    v match
      case Some(value) => inner.asInstanceOf[Weaver[Any]].pack(p, value, config)
      case None        => p.packNil

  override def unpack(u: Unpacker, context: WeaverContext): Unit =
    // Same logic as existing optionWeaver given

class SeqWeaver(elem: Weaver[?], targetType: Class[?]) extends Weaver[Seq[?]]:
  // Same logic as existing seqWeaver given

class MapWeaver(key: Weaver[?], value: Weaver[?]) extends Weaver[Map[?, ?]]:
  // Same logic as existing mapWeaver given

// Keep existing givens, have them delegate to classes
given optionWeaver[A](using elementWeaver: Weaver[A]): Weaver[Option[A]] =
  OptionWeaver(elementWeaver).asInstanceOf[Weaver[Option[A]]]
```

### 3. MethodCodec - Combine Param Weavers with CName Matching

**File**: `uni/src/main/scala/wvlet/uni/http/rpc/MethodCodec.scala`

```scala
package wvlet.uni.http.rpc

import wvlet.uni.json.JSON
import wvlet.uni.surface.{CName, MethodSurface}
import wvlet.uni.weaver.Weaver

case class MethodCodec(
    method: MethodSurface,
    paramWeavers: IndexedSeq[Weaver[?]],
    returnWeaver: Weaver[?]
):
  // Pre-compute canonical name lookup for flexible param matching
  private val paramsByCanonicalName: Map[String, (Int, MethodParameter, Weaver[?])] =
    method.args.zip(paramWeavers).zipWithIndex.map { case ((p, w), i) =>
      CName.toCanonicalName(p.name) -> (i, p, w)
    }.toMap

  /**
   * Decode request body to method parameters.
   * Format: {"request": {"param1": v1, "param2": v2}}
   * Uses CName for flexible matching (userId, user_id, user-id all match)
   */
  def decodeParams(json: String): Seq[Any] =
    if json.isBlank then
      decodeFromMap(Map.empty)
    else
      JSON.parse(json) match
        case obj: JSON.JSONObject =>
          obj.get("request") match
            case Some(req: JSON.JSONObject) => decodeFromMap(req.value)
            case Some(_) =>
              throw RPCStatus.INVALID_REQUEST_U1.newException("'request' must be object")
            case None =>
              throw RPCStatus.INVALID_REQUEST_U1.newException("Missing 'request' field")
        case _ =>
          throw RPCStatus.INVALID_REQUEST_U1.newException("Body must be JSON object")

  def encodeResult(value: Any): String =
    returnWeaver.asInstanceOf[Weaver[Any]].toJson(value)

  private def decodeFromMap(map: Map[String, JSON.JSONValue]): Seq[Any] =
    val numParams = method.args.size
    val results = Array.ofDim[Any](numParams)
    val found = Array.fill(numParams)(false)

    // Match incoming keys using canonical names
    for (key, value) <- map do
      paramsByCanonicalName.get(CName.toCanonicalName(key)) match
        case Some((i, param, weaver)) =>
          // Use fromJSONValue to avoid JSON string roundtrip
          results(i) = weaver.asInstanceOf[Weaver[Any]].fromJSONValue(value)
          found(i) = true
        case None =>
          // Ignore unknown parameters

    // Fill missing with defaults or throw error
    for i <- 0 until numParams if !found(i) do
      val param = method.args(i)
      results(i) = param.getDefaultValue.getOrElse(
        throw RPCStatus.INVALID_ARGUMENT_U2.newException(
          s"Missing required parameter: ${param.name}"
        )
      )

    results.toSeq
```

### 4. RPCRoute

**File**: `uni/src/main/scala/wvlet/uni/http/rpc/RPCRoute.scala`

```scala
package wvlet.uni.http.rpc

case class RPCRoute(
    serviceName: String,
    methodName: String,
    path: String,
    codec: MethodCodec
)
```

### 5. RPCRouter

**File**: `uni/src/main/scala/wvlet/uni/http/rpc/RPCRouter.scala`

```scala
package wvlet.uni.http.rpc

import wvlet.uni.surface.{MethodSurface, Surface}
import wvlet.uni.weaver.Weaver

object RPCRouter:
  inline def of[T](instance: T): RPCRouter =
    val surface = Surface.of[T]
    new RPCRouter(Surface.methodsOf[T], instance, surface.fullName)

class RPCRouter(
    methods: Seq[MethodSurface],
    val instance: Any,
    val serviceName: String
):
  private val objectMethods = Set(
    "equals", "hashCode", "toString", "getClass",
    "notify", "notifyAll", "wait"
  )

  val codecs: Map[String, MethodCodec] = methods
    .filterNot(m => objectMethods.contains(m.name))
    .map { m =>
      val paramWeavers = m.args.map(p => Weaver.fromSurface(p.surface)).toIndexedSeq
      val returnWeaver = Weaver.fromSurface(m.returnType)
      m.name -> MethodCodec(m, paramWeavers, returnWeaver)
    }
    .toMap

  val routes: Seq[RPCRoute] = codecs.map { (name, codec) =>
    RPCRoute(serviceName, name, s"/${serviceName}/${name}", codec)
  }.toSeq
```

### 6. RPCHandler

**File**: `uni-netty/src/main/scala/wvlet/uni/http/netty/RPCHandler.scala`

```scala
package wvlet.uni.http.netty

import wvlet.uni.http.*
import wvlet.uni.http.rpc.*
import wvlet.uni.rx.Rx

class RPCHandler(router: RPCRouter) extends RxHttpHandler:
  private val routeMap = router.routes.map(r => r.path -> r).toMap

  override def handle(request: Request): Rx[Response] =
    if request.method != HttpMethod.POST then
      Rx.single(Response(HttpStatus.MethodNotAllowed_405))
    else
      routeMap.get(request.path) match
        case Some(route) => handleRPC(request, route)
        case None => Rx.single(Response.notFound(s"Not found: ${request.path}"))

  private def handleRPC(request: Request, route: RPCRoute): Rx[Response] =
    try
      val args = route.codec.decodeParams(request.contentAsString)
      val result = route.codec.method.call(router.instance, args*)

      result match
        case rx: Rx[?] =>
          rx.map(v => successResponse(v, route.codec))
            .recover { case e => errorResponse(e) }
        case value =>
          Rx.single(successResponse(value, route.codec))
    catch
      case e: RPCException => Rx.single(e.toResponse)
      case e: Exception => Rx.single(errorResponse(e))

  private def successResponse(value: Any, codec: MethodCodec): Response =
    Response.ok.withJsonContent(codec.encodeResult(value))

  private def errorResponse(e: Throwable): Response = e match
    case rpc: RPCException => rpc.toResponse
    case _ => RPCStatus.INTERNAL_ERROR_I0.newException(e.getMessage, e).toResponse
```

## File Structure

```
uni/src/main/scala/wvlet/uni/
├── weaver/
│   ├── Weaver.scala                 # Add fromSurface()
│   └── codec/
│       └── PrimitiveWeaver.scala    # Extract OptionWeaver, SeqWeaver, MapWeaver classes
└── http/rpc/
    ├── RPCStatus.scala              # ✅ Done
    ├── RPCException.scala           # ✅ Done
    ├── RPCRouter.scala              # NEW
    ├── RPCRoute.scala               # NEW
    └── MethodCodec.scala            # NEW

uni-netty/src/main/scala/wvlet/uni/http/netty/
└── RPCHandler.scala                 # NEW
```

## Implementation Sequence

1. **Extract weaver classes** - OptionWeaver, SeqWeaver, MapWeaver from existing givens
2. **Weaver.fromSurface** - Compose existing weavers
3. **MethodCodec** - Decode named params with CName, encode result
4. **RPCRoute** - Simple data class
5. **RPCRouter** - Build routes from Surface
6. **RPCHandler** - Netty integration
7. **Tests**

## Example

```scala
package com.example.api

case class User(id: Long, name: String) derives Weaver

trait UserService:
  def getUser(id: Long): User
  def createUser(name: String, email: String): User

class UserServiceImpl extends UserService:
  def getUser(id: Long) = User(id, "Alice")
  def createUser(name: String, email: String) = User(1, name)

// Server
val router = RPCRouter.of[UserService](UserServiceImpl())
val server = NettyServer(8080).withHandler(RPCHandler(router))
```

```bash
# All these requests work (CName matching)
curl -X POST http://localhost:8080/com.example.api.UserService/getUser \
  -d '{"request": {"id": 123}}'

curl -X POST http://localhost:8080/com.example.api.UserService/createUser \
  -d '{"request": {"name": "Bob", "email": "bob@test.com"}}'

# snake_case also works
curl -X POST http://localhost:8080/com.example.api.UserService/createUser \
  -d '{"request": {"user_name": "Bob", "e_mail": "bob@test.com"}}'
```
